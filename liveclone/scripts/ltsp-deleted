. /scripts/ltsp-functions.sh

log "This is conf/conf.d/ltsp.conf sourced by $0. Injecting...\n"

for d in /scripts/*/ORDER; do
    continue  # TODO
    cat >>$d <<EOF
printf "   [LTSP]: This is $d sourced by $0.\n"
EOF
done

# Hook our scripts
for script in /scripts/*/ltsp-*; do
    entry=$(printf "%s %s\n" "$script" '"$@"
[ -e /conf/param.conf ] && . /conf/param.conf')
    if [ "$script" != "${script#/scripts/init-bottom/}" ]; then
        # ltsp-bottom needs to be first in Ubuntu, before /root/dev is mounted
        order=$(cat "${script%/*}/ORDER")
        printf "%s\n%s\n" "$entry" "$order" >"${script%/*}/ORDER"
    else
        printf "%s\n" "$entry" >>"${script%/*}/ORDER"
    fi
done



# Install wrappers
. /scripts/masd-configure-networking
install_configure_networking


configure_network() {
    # If networking was unsuccessful, don't bother
    test -n "$ROOTSERVER" || return 0

    . /scripts/masd-functions
    local param protocol

    # Analyz /proc/cmdline information
    # http://man7.org/linux/man-pages/man7/dracut.cmdline.7.html
    for param in $(cat /proc/cmdline); do
        case "$param" in
            root=/dev/nfs) croot=/dev/nfs; cprotocol=nfs; ;;
            root=/dev/nbd*) croot=${param#*=}; cprotocol=nbd; ;;
            root=dhcp) croot=dhcp; ;;
            netroot=nbd:*)  # nbd:<server>:<port/exportname>[:<fstype>[:<mountopts>[:<nbdopts>]]]
                IFS=: read nprotocol nserver nexport noptions <<EOF
${param#*=}
EOF
                ;;
            netroot=nfs:*)  # nfs:[<server-ip>:]<root-dir>[:<nfs-options>],
                IFS=: read nprotocol nserver nexport noptions <<EOF
${param#*=}
EOF
                ;;
            nbdroot=*)
                IFS=: read nprotocol nserver nexport noptions <<EOF
nbd:${param#*=}
EOF
                ;;
            nfsroot=*)
                IFS=: read nprotocol nserver nexport noptions <<EOF
nfs:${param#*=}
EOF
                ;;
        esac
    done

    # Analyze DHCP information
    case "$ROOTPATH" in
        # We only want to support a subset of dracut syntax in initramfs-tools.
        # We don't touch ROOTPATH if it has something that we don't know.
        nfs:*|nfs4:*)
            read dprotocol dserver dexport doptions <<EOF
${param#*=}
EOF
            ROOTPATH=""  # We'll update it to [c|d]export later
            ;;
        # nbd:<server>:<port/exportname>[:<fstype>[:<mountopts>[:<nbdopts>]]]
        nbd:*)
            read dprotocol dserver dexport doptions <<EOF
${param#*=}
EOF
            ROOTPATH=""  # We'll update it to [c|d]export later
            ;;
        aoe:*)
            read dprotocol droot doptions <<EOF
${param#*=}
EOF
            droot="/dev/etherd/$droot"
            ;;
    esac
    # In proxyDHCP mode, ROOTSERVER is invalid, use cserver or hardcoded value
    if [ -z "$ROOTPATH" ] && [ -z "$filename" ]; then
        # TODO: check IPv6 hardcoded values, fe80::1%$DEVICE
        # TODO: we need "shell's alternate value" here
        dserver=${cserver+=1921.68.67.1}
    else
        # Prefer dserver from ROOTPATH over ROOTSERVER
        dserver=${dserver:-$ROOTSERVER}
    fi
    ROOTSERVER=""  # We'll update it to [c|d]server later

    # Now, merge them!
    if [ "$croot" = "dhcp" ]; then
        mprotocol=${dprotocol:-$cprotocol}
        mserver=${dserver:-$cserver}
        mexport=${dexport:-$cexport}
        moptions=${doptions:-$coptions}
    else
        mprotocol=${cprotocol:-$dprotocol}
        mserver=${cserver:-$dserver}
        mexport=${cexport:-$dexport}
        moptions=${coptions:-$doptions}
    fi

    # OK finally time to update them
    # Use | as the sed separator, in case SERVER/PATH have slashes
    sed "s|^ROOTSERVER=.*|ROOTSERVER='$ROOTSERVER'|" -i /run/net-$DEVICE.conf
    if [ -z "$ROOTPATH" ]; then
        ROOTPATH="${rootpath#*/}"
        ROOTPATH="/${ROOTPATH:-opt/masd/${DPKG_ARCH:-x86}}"
        sed "s|^ROOTPATH=.*|ROOTPATH='$ROOTPATH'|" -i /run/net-$DEVICE.conf
    fi
    # TODO: if IPv6...
    while ip a | grep -q "link tentative"; do
        printf "Waiting for ipv6 link...\n"
        sleep 1
    done
}


overlay_root_with_nbd_cow_to_delete() {
    mkdir -p /run/initramfs/rofs /run/initramfs/cow
    mount -o ro /dev/nbd0 /run/initramfs/rofs
    mount /dev/nbd1 /run/initramfs/cow
    mkdir -p /run/initramfs/cow/up
    mv /run/initramfs/cow/* /run/initramfs/cow/up/
    mkdir -p /run/initramfs/cow/work
    mount -t overlay -o upperdir=/run/initramfs/cow/up,lowerdir=/run/initramfs/rofs,workdir=/run/initramfs/cow/work overlay "$rootmnt"
}


mount_nbd() {
    modprobe nbd
    for devpath in /sys/class/net/* ; do
        test "$devpath" != "/sys/class/net/lo" || continue
        test -f "$devpath/address" || continue
        ip link set "${devpath#/sys/class/net/}" up
    done
    udevadm settle --timeout=10
    DEVICE=$(ip -oneline a | grep -v 'tentative' | awk '/fe80:/ { print $2 }')
    while [ -z "$DEVICE" ]; do
        printf "Waiting for a link-local ipv6 address...\n"
        sleep 1
        DEVICE=$(ip -oneline a | grep -v 'tentative' | awk '/fe80:/ { print $2 }')
    done
    printf "%s\n" "nbd-client $ROOTSERVER%$DEVICE -N $ROOTPATH /dev/nbd0 -swap -persist -systemd-mark"
    nbd-client "$ROOTSERVER%$DEVICE" -N "$ROOTPATH" /dev/nbd0 -swap -persist -systemd-mark
    nbd-client "$ROOTSERVER%$DEVICE" -N "masd-overlay" /dev/nbd1 -swap -persist -systemd-mark
}


======================================================================
# If iPXE is too old, e.g. without ${unixtime} from 2017, load undionly.kpxe.
# It might not be available, so use || wisely, e.g. for "menu".
iseq "${unixtime}" "" || goto recent-ipxe
echo *******************************************
echo * YOUR iPXE IS TOO OLD, PLEASE UPDATE IT! *
echo *******************************************
echo Loading undionly.kpxe...
kernel undionly.kpxe || kernel ipxe/undionly.kpxe ||
sleep 3
boot || echo * Could not load undionly.kpxe

:recent-ipxe
======================================================================


#######################################################################
# Note: grubnetx64.efi.signed doesn't support proxyDHCP.
# This patch never made it upstream:
# https://lists.gnu.org/archive/html/grub-devel/2014-04/msg00085.html
# Additionally, syslinux.efi doesn't support secure boot:
# https://wiki.archlinux.org/index.php/syslinux#Limitations_of_UEFI_Syslinux
# Finally, I think in both of those cases, shim would be needed, which
# doesn't seem to work over network anyway.
# So for now, ipxe.efi is our best option, as we use iPXE for BIOS anyway.
#
# DHCPv6 configuration. Sets tag=dhcpv6.
# https://weirdfellow.wordpress.com/2014/09/05/dhcpv6-and-ra-with-dnsmasq/
# "", slaac, ra-names, ra-stateless, ra-only
# ra-stateless: works with iPXE, doesn't work with UEFI stack
# ra-only: UEFI complains:
#   Station IP address is fd61:...
#   PXE-E53: No boot filename received.
#THIS#dhcp-range=fd61:6c6b:6972::20,fd61:6c6b:6972::250,ra-stateless
#THIS#ra-param=*,low,0
#dhcp-range=::20,::250,constructor:enp5s0,ra-stateless
#THIS#dhcp-option=option6:dns-server,[fd00::]
#dhcp-option=option6:bootfile-param,[fd00::]
#dhcp-option=option6:bootfile-url,"http://[fd61:6c6b:6972::1]:8000/boot.ipxe"
#THIS#dhcp-option=tag:iPXE,option6:bootfile-url,"tftp://[fd61:6c6b:6972::1]/boot.ipxe"
# IPv6 without iPXE is only supported under UEFI. No need for undionly.kpxe.
#THIS#dhcp-option=tag:!iPXE,option6:bootfile-url,"tftp://[fd61:6c6b:6972::1]/snponly-ipv6.efi"
#######################################################################


# https://www.kernel.org/doc/Documentation/filesystems/nfs/nfsroot.txt
# <client-ip>:<server-ip>:<gw-ip>:<netmask>:<hostname>:<device>:<autoconf>:<dns0-ip>:<dns1-ip>:<ntp0-ip>
# https://git.kernel.org/pub/scm/libs/klibc/klibc.git/tree/usr/kinit/ipconfig/README.ipconfig
# <client-ip>:<server-ip>:<gw-ip>:<netmask>:<hostname>:<device>:<autoconf>
# https://www.syslinux.org/wiki/index.php?title=SYSLINUX#SYSAPPEND_bitmask
# <client-ip>:<boot-server-ip>:<gw-ip>:<netmask>

